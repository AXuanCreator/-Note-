# 链表

**此笔记由AXuanCreator制作,部分资料来源于网络,GITHUB地址:[AXuanCreator/NOTE-Data-Structure-and-Algorithms: 数据结构与算法的一些笔记，目前基于C++ (github.com)](https://github.com/AXuanCreator/NOTE-Data-Structure-and-Algorithms)**



## 单链表

### ---------------------

 #### 创建链表模板
```c
typedef struct Node
{
    int val;
    struct Node *next;
}MyLinkList;
```
> MyLinkList是结构的别名，`int val`可替换为任意类型

#### 创建头节点
```c
MyLinkedList* listHeadCreat()
{
    MyLinkedList *list_head = (MyLinkedList*)malloc(sizeof(MyLinkedList));  //链表头内存分配
    /*初始化链表头，此时val值可为任意*/
    list_head->val=0;
    list_head->next=NULL;//next为NULL，后期加入或删除节点

    return list_head;  //返回链表头
}
```
>链表头`list_head`可为<mark>临时链表头</mark>，后期可载入其他链表头

#### 载入首位节点
```c
void listAddHead(MyLinkedList *list_head,int val)
{
    MyLinkedList *node = (MyLinkedList*)malloc(sizeof(MyLinkedList));  //node为结点，初始化节点

    node->val=10;
    node->next=NULL; //无论如何，next都需先初始化为NULL

    /*若链表本身为空*/
    if(list_head->next == NULL){  
        list_head->next = node;  //next = node，让next指向node所指向的链表
        return;
    }
    /*若链表头连接着其他链表*/
    else{
        node->next=list_head->next;   //将原链表挂在新结节点后面
        list_head->next=node;         //再将链表头与新链表连接
    }
}

```

解析`list_head->next = node`
[`list_head->next`]是一个**MyLinkedList**类型的指针，它指向**MyLinkedList**这一结构，而`node`同样是**MyLinkedList**的指针，因此含义为**将`next指针`指向node所指向的结构**

#### 载入末尾节点
```c
void listAddTail(MyLinkedList *list_head, int val)
{
    /*新建节点*/
    MyLinkedList *node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    node->val = val;
    node->next = NULL;

    /*创建临时移动型链表头*/
    MyLinkedList *list_move = list_head; //此时list_move为临时链表头，用于下面的循环

    /*开始移动*/
    while (list_move->next != NULL)  
    {
        list_move = list_move->next;
    }

    /*载入链表尾*/
    list_move->next=node;
}
```

解析`while (list_move->next != NULL)  
    {
        list_move = list_move->next;
    }`
    设节点为1->2->3,在`list_move`处于节点2时，语句`list_move=list_move->next`会使其移动至节点3，而**节点3->next为NULL**，因此在while判断时指向NULL，退出循环

>`while(list_move->next != NULL)`会停在最后一个节点
>`while(list_move != NULL)`会停在最后一个节点之后

#### 寻找任意节点信息
```c
void listGet(MyLinkedList *list_head, int index)
{
    /*判断index是否合法*/
    if (index < 0 || list_head->next == NULL)
        return -1;

    /*新建首位移动节点*/
    int now = 0;
    MyLinkedList *list_move = list_head->next; //首位节点从0开始

    /*移动节点*/
    while (now < index)
    {
        if (list_move == NULL)
        {
            return -1;
        }
        list_move = list_move->next;
        now++;
    }
    if (list_move != NULL)
        return list_move->val;

    return -1;
}
```

为何需要`if (list_move != NULL)`
1.当**index=0**时，无法进入循环，此时直接返回对应的值
2.当**index=链表长度+1**时，now=index时，`list_move=NULL`

>return -1代表无此节点

**while循环还有第二种写法，此时<mark>不需要判断语句</mark>**
```c
/*移动节点*/
while (list_move != NULL)
{
    if(now==index)
        return list_move->val;

    list_move=list_move->next;
    now++;
}

return -1;
```
>若`list_move == NULL`，即代表index超出链表长度
>当`index=0`时，仍然可以进入循环

#### 任意位置载入节点
```c
int listAddIndex(MyLinkedList *list_head , int index,int val)
{
    /*判断index是否为非正数，若是，则实现首位插入*/
    if(index<=0)
        listAddHead(list_head,val);

    /*新建待插入节点*/
    MyLinkedList *node = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    node->val=val;
    node->next=NULL;

    /*新建首位移动节点*/
    MyLinkedList *list_move = list_head->next;
    int now=0;

    /*插入*/
    while(list_move->next!=NULL)
    {
        if(now==index-1)
            break;  //需在index前1位停止循环，此时节点为index-1号
        
        list_move=list_move->next;
        now++;
    }

    /*判断now是否合法*/
    if(now!=index-1)
        return; 

    /*节点载入*/
    node->next=list_move->next;
    list_move->next=node;
    
}
```

解析`if(now!=index-1) {return;}`
当条件为TRUE时，即`list_move->next==NULL`，此时移动节点位于链表的**最后一个节点**，而now与index-1的关系未知，无法载入。这种情况的出现一般是*index超出链表长度*

>链表索引一般从0开始计算
>当节点需要插入3号节点时，**原3号节点**需向后移动，变成4号节点(即`list_move->next`)。此时`node->next`指向`list_move->next`，而`list_move->next`（此时代表**二号节点的下一个节点**）指向node

#### 任意位置删除节点
```c
void listDelIndex(MyLinkedList *list_head, int index)
{
    /*判断index状态*/
    if (index < 0 || list_head->next == NULL)
        return;
	
    // 当为首位节点时，直接删除即可(head不存储数据)
    // 在这个实例中，head不当作0号节点
    if (index == 0)
    { 
        list_head->next = list_head->next->next;
        return;
    }

    /*新建首位移动节点*/
    MyLinkedList *list_move = list_head->next;
    int now = 0;

    /*节点删除*/
    while (list_move->next != NULL)
    {
        if (now == index - 1)
            break;

        list_move = list_move->next;
        now++;
    }

    /*判断*/
    if (list_move->next != NULL && now == index - 1)
        list_move->next = list_move->next->next;
}
```

解析`if (list_move->next != NULL && now == index - 1)`
退出循环有两种情况：
①正常退出：now=index-1
②问题退出：`list_move->next == NULL`,此时不清楚**now与index-1**的关系，若两者不相等，则index超出链表长度。

注意，无法通过此函数删除尾节点
设尾节点为5，当`list_move`处于5（`now=5`）时，**循环通过while退出**。而index也为5，因此无法删除



#### 节点打印
```c
void listPrintf(MyLinkedList *list_head , int len)
{
    /*创建移动节点*/
    MyLinkedList *list_move = list_head->next;

    for(int i=0;i<len;i++)
    {
        printf("%d",list_move->val);
        list_move=list_move->next;
    }
}
```
#### 内存释放
```c
void listNodeFree(MyLinkedList *node)
{
    if(node->next!=NULL)
    {
        listNodeFree(node->next);
        node->next=NULL;
    }
    free(node);  
}

void listFree(MyLinkedList *list_head)
{
    listNodeFree(list_head);
}
```
>`node->next=NULL`是为了避免指向错误，因为此时的`node->next`已经**free**

#### 完整实现
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node 
{
    int val;
    struct Node *next;
} MyLinkedList;

/*创建链表*/
MyLinkedList* listHeadCreat()
{
    MyLinkedList *list_head = (MyLinkedList *)malloc(sizeof(MyLinkedList)); //链表头内存分配
    /*初始化链表头，此时val值可为任意*/
    list_head->val = 0;
    list_head->next = NULL; // next为NULL，后期加入或删除结点

    return list_head; //返回链表头
}

/*载入链表头*/
void listAddHead(MyLinkedList *list_head, int val)
{
    MyLinkedList *node = (MyLinkedList *)malloc(sizeof(MyLinkedList)); // node为结点，初始化结点

    node->val = val;
    node->next = NULL; //无论如何，next都需先初始化为NULL

    /*若链表本身为空*/
    if (list_head->next == NULL)
    {
        list_head->next = node; // next = node，让next指向node所指向的链表
        return;
    }
    /*若链表头连接着其他链表*/
    else
    {
        node->next = list_head->next; //将原链表挂在新结点后面
        list_head->next = node;       //再将链表头与新链表连接
    }
}

/*载入链表尾*/
void listAddTail(MyLinkedList *list_head, int val)
{
    /*新建节点*/
    MyLinkedList *node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    node->val = val;
    node->next = NULL;

    /*创建临时移动型链表头*/
    MyLinkedList *list_move = list_head; //此时list_move为临时链表头，用于下面的循环

    /*开始移动*/
    while (list_move->next != NULL)
    {
        list_move = list_move->next;
    }

    /*载入链表尾*/
    list_move->next = node;
}

/*寻找任意节点信息*/
int listGet(MyLinkedList *list_head, int index)
{
    /*判断index是否合法*/
    if (index < 0 || list_head->next == NULL)
        return (-1);

    /*新建首位移动节点*/
    int now = 0;
    MyLinkedList *list_move = list_head->next; //首位节点从0开始

    /*移动节点*/
    /*while (now < index)
    {
        if (list_move == NULL)
        {
            return -1;
        }
        list_move = list_move->next;
        now++;
    }
    if (list_move != NULL)
        return list_move->val;*/

    while (list_move != NULL)
    {
        if (now == index)
            return list_move->val;

        list_move = list_move->next;
        now++;
    }

    return -1;
}

/*任意位置插入节点*/
void listAddIndex(MyLinkedList *list_head, int index, int val)
{
    /*判断index是否为非正数，若是，则实现首位插入*/
    if (index <= 0)
        listAddHead(list_head, val);

    /*新建待插入节点*/
    MyLinkedList *node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    node->val = val;
    node->next = NULL;

    /*新建首位移动节点*/
    MyLinkedList *list_move = list_head->next;
    int now = 0;

    /*插入*/
    while (list_move->next != NULL)
    {
        if (now == index - 1)
            break; //需在index前1位停止循环，此时节点为index-1号

        list_move = list_move->next;
        now++;
    }

    /*判断now是否合法*/
    if (now != index - 1)
        return;

    /*节点载入*/
    node->next = list_move->next;
    list_move->next = node;
}

/*任意位置删除节点*/
void listDelIndex(MyLinkedList *list_head, int index)
{
    /*判断index状态*/
    if (index < 0 || list_head->next == NULL)
        return;

    if (index == 0)
    { //当为首位节点时，直接删除即可
        list_head->next = list_head->next->next;
        return;
    }

    /*新建首位移动节点*/
    MyLinkedList *list_move = list_head->next;
    int now = 0;

    /*节点删除*/
    while (list_move->next != NULL)
    {
        if (now == index - 1)
            break;

        list_move = list_move->next;
        now++;
    }

    /*判断*/
    if (list_move->next != NULL && now == index - 1)
        list_move->next = list_move->next->next;
    
}

/*内存释放*/
void listNodeFree(MyLinkedList *node)
{
    if(node->next!=NULL)
    {
        listNodeFree(node->next);
        node->next=NULL;
    }
    free(node);  
}

void listFree(MyLinkedList *list_head)
{
    listNodeFree(list_head);
}

/*节点打印*/
void listPrintf(MyLinkedList *list_head , int len)
{
    /*创建移动节点*/
    MyLinkedList *list_move = list_head->next;

    for(int i=0;i<len;i++)
    {
        printf("%d",list_move->val);
        list_move=list_move->next;
    }
}
int main()
{
    MyLinkedList *list_head = listHeadCreat();

    listAddHead(list_head,1);
    listAddIndex(list_head,1,2);
    listAddIndex(list_head,2,3);
    listAddTail(list_head,4);
    listDelIndex(list_head,2);
    listPrintf(list_head,3);
    listFree(list_head);

    system("pause");
}

```
#### 需要注意的点
>1. 在调用 next 字段之前，始终检查节点是否为空。
>2. 仔细定义循环的结束条件

#### 小题
##### 删除倒数第N个节点

**示意图**
![549773013230260](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage549773013230260.png)

###### 长度法
```c
/*删除倒数第n个节点（长度法）【head】存储数据*/
struct MyLinkedList *removeListFromEnd(struct MyLinkedList *head, int n)
{
    // 初始化节点
    MyLinkedList *list_move = head;

    // 长度计算
    int len = 0;
    int new = 0;
    while (list_move != NULL)
    {
        len++;
        list_move = list_move->next;
    }
    list_move = head;
    int new_len = len - n;

    // 定位至待删除节点的前一位
    while (list_move != NULL && new < new_len)
    {
        if (new == new_len - 1)
            break;
        list_move = list_move->next;
        new ++;
    }

    // 删除节点判断
    if (list_move->next != NULL && new_len != 0)
        list_move->next = list_move->next->next;
    if (new_len == 0)
    {
        head = list_move->next;
    }

    return head;
}
```
###### 双指针法
```c
/*删除第N个节点（双指针法）【head存储数据】*/
struct Node* removeNthFromEnd(MyLinkedList* head, int n){
    //双指针声明
    MyLinkedList* list_slow;
    MyLinkedList* list_fast;

    //快指针前进N位
    list_slow = head;
    list_fast = head;
    for(int i=0;i<n;i++){
        if(list_fast->next == NULL)
        {
            list_fast=NULL;
            break;
        }
        list_fast=list_fast->next;
    } 
    
    //快慢指针同时前进
    while(list_fast!=NULL && list_fast->next!=NULL)
    {
        list_fast=list_fast->next;
        list_slow=list_slow->next;
    }
    
    //判断
    if(list_fast==NULL)
        head=head->next;
    else
        list_slow->next=list_slow->next->next;
        
    return head;
}
```

解析`if(list_fast->next == NULL)
        {
            list_fast=NULL;
            break;
        }`
当**链表长度-N为0时**，`list_fast`会溢出，此时需手动设置`list_fast`为`NULL`

##### 删除链表指定数据
**示意图**
<img src="D:\Files_Work\Vnote\CandCPP\数据结构与算法\vx_images\183901515230263.png" alt="183901515230263" style="zoom:50%;" />

###### 双指针法（虚拟头链表）
```c
/*删除链表指定元素*/
struct Node *removeElements(MyLinkedList *head, int val)
{
    if (head == NULL)  //判断是否为空链表
        return head;

    MyLinkedList *pre_head = (MyLinkedList *)malloc(sizeof(MyLinkedList));  //虚拟链表头
    pre_head->next = head;
    MyLinkedList *pre = pre_head;  //前指针
    MyLinkedList *cur = head;      //后指针

    //从真实头链表开始判断
    while (cur != NULL)
    {
        if (cur->val == val)  
        {
            pre->next = cur->next;  //删除操作 
            cur = cur->next;
        }
        else 
        {
            pre = cur;  //指针重置于非VAL链表处
            cur = cur->next;
        }
    }

    return pre_head->next;
}

```
alert-i
①虚拟头链表`pre_head`指向`head`，因此在判断时可以做到**直接删除符合条件的头链表**
②`pre`指针会在**与`val`不相等的节点处重置**
③`return pre_head->next`才是返回真正的头链表指针，**`pre_head`**永远是虚拟头链表

###### 递归法
```c
/*删除链表指定元素--递归*/
struct Node* removeElements(MyLinkedList* head, int val) {
    if (head == NULL) {
        return head;
    }
    head->next = removeElements(head->next, val);
    return head->val == val ? head->next : head;
}
```
alert-d
注意:
**头节点的删除**已在`return head->val == val ? head->next : head;`中完成，如果`head->val == val`，会返回下一个节点

>当节点数量多时，**请勿使用递归**，会导致栈满
##### 奇偶链表
```
题目要求：
给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。
第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。
请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。
你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。
```
**示意图**
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage420493919230263.png" alt="420493919230263" style="zoom:50%;" />

###### 分离节点后合并
```c
struct ListNode* oddEvenList(struct ListNode* head)
{
    if(head==NULL)
        return head;
    
    struct ListNode* evenhead = head->next;  //创建偶索引链表头指针
    struct ListNode* even = evenhead;
    struct ListNode* odd = head;

    while(even!=NULL && even->next!=NULL)
    {
        odd->next=even->next;
        odd=odd->next;
        even->next=odd->next;
        even=even->next;     
    }
    odd->next=evenhead;

    return head;
}
```

`while(even!=NULL && even->next!=NULL)`为何不能写成`while(even!=NULL || even->next!=NULL)`
当`even!=NULL`而`even->next==NULL`时，用第二种写法会发生报错

##### 反转链表
**示意图**
![138054809230261](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage138054809230261.png)

###### 迭代法/双指针法
```c
/*反转链表-迭代*/
struct Node* reverseList(MyLinkedList* head){ 
    MyLinkedList* pre=NULL;  //前一位
    MyLinkedList* cur=head;  //后一位

    while(cur!=NULL)
    {
        MyLinkedList* temp = cur->next; //存储cur后一位节点
        cur->next = pre;  //让cur的后一位指向前一位
        pre = cur;
        cur = temp;
    }

    return pre;
}
```
###### 递归法
```c
/*反转链表-递归*/
struct Node* reverseList(MyLinkedList* head){
    if (head==NULL || head->next == NULL)
        return head;

    MyLinkedList* Newhead = reverseList(head->next);   //最后一位，也是新链表的头部
    
    head->next->next = head;  //令head的后一位节点指向head
    head->next = NULL;  //令head指向NULL （因为head与后一位指向方向已反转，head无指向节点)
    
    return Newhead;
}
```

定义`Newhead`的关键语句是`return head`，后面的`return Newhead`实际上是不断返回本身
`head->next->next=head`意义是**让head的后一位指向head**，而此时head不再具有指向后一位的功能，因此`head->next=NULL`

>`return Newhead`返回一个反转链表
##### 回文链表
**题目要求**
```
给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
```
**示意图**
![119590318230264](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage119590318230264.png)

###### 双指针法

```c
bool isPalindrome(struct ListNode *head)
{
    // 空链表和只有一个节点的链表都是回文链表
    if (head == NULL || head->next == NULL)
    {
        return true;
    }

    // 计算链表长度
    int len = 0;
    struct ListNode *p = head;
    while (p != NULL)
    {
        len++;
        p = p->next;
    }

    // 将链表前半部分反转
    struct ListNode *prev = NULL;
    struct ListNode *cur = head;
    for (int i = 0; i < len / 2; i++)
    {
        //迭代
        struct ListNode *next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }

    // 如果链表长度是奇数，跳过中间节点
    if (len % 2 == 1)
    {
        cur = cur->next;
    }

    // 比较前半部分和后半部分是否相同
    while (prev != NULL && cur != NULL)
    {
        if (prev->val != cur->val)
        {
            return false;
        }
        prev = prev->next;
        cur = cur->next;
    }

    return true;
}

```
###### 递归
```c
// 定义一个全局变量frontPointer，指向链表头部
struct ListNode *frontPointer;

// 递归函数，用于检查从frontPointer开始的链表节点是否回文
bool recursivelyCheck(struct ListNode *currentNode)
{
    // 递归终止条件：如果当前节点不为空
    if (currentNode != NULL)
    {
        // 递归调用，先检查后续节点是否回文，如果不是则返回false
        if (!recursivelyCheck(currentNode->next))
        {
            return false;
        }
        // 检查当前节点和frontPointer所指向的节点的值是否相等，如果不是则返回false
        if (currentNode->val != frontPointer->val)
        {
            return false;
        }
        frontPointer = frontPointer->next;
    }
    // 如果遍历到链表末尾，说明链表是回文的，返回true
    return true;
}

// 判断链表是否回文的函数
bool isPalindrome(struct ListNode *head)
{
    frontPointer = head;
    return recursivelyCheck(head);
}

```

注意：
若链表对称节点出现**值不相等**的情况，`if (currentNode->val != frontPointer->val) {
            return false;
        }`会返回`false`
        而对于`if (!recursivelyCheck(currentNode->next)) {
            return false;
        }`而言，会**进入if语句**，从而进入快速弹出栈阶段


##### 合并两个有序链表
**题目要求**

将**两个升序**链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示意图**
<img src="D:\Files_Work\Vnote\CandCPP\数据结构与算法\vx_images\392020719230265.png" alt="392020719230265" style="zoom:50%;" />

###### 迭代法
```c
    struct ListNode *mergeTwoLists(struct ListNode *list1, struct ListNode *list2)
{
    // 判断是否为空链表
    if (list1 == NULL)
        return list2;
    if (list2 == NULL)
        return list1;

    // 指针创建,cur的作用是给prev重新定位
    struct ListNode *prevA = list1;
    struct ListNode *prevB = list2;
    struct ListNode *curA = prevA;
    struct ListNode *curB = prevB;

    while (prevA != NULL && prevB != NULL && (swA || swB))
    {
        if (prevA->val <= prevB->val)
        {
            //用于快速跳过符合条件的节点
            while (prevA->next != NULL && prevA->next->val <= prevB->val) 
            {
                prevA = prevA->next;
                if (prevA->next != NULL)
                    curA = prevA->next;
            }

            // 未进入while循环时cur自动向前,同时是prev=NULL的关键
            if (curA != prevA->next)
                curA = prevA->next;
 
            //合并节点并重新定位
            prevA->next = prevB;
            prevA = curA; 
        }
        else if (prevB->val < prevA->val)
        {
            while (prevB->next != NULL && prevB->next->val < prevA->val)
            {
                prevB = prevB->next;
                if (prevB->next != NULL)
                    curB = prevB->next;
            }

            if (curB != prevB->next)
                curB = prevB->next;

            prevB->next = prevA;
            prevB = curB; 
        }
    }

    //根据首节点的大小判断谁的指针先发生改变
    if (list1->val <= list2->val)
        return list1;
    else
        return list2;
}
```

###### 递归
```c
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)
{
    if(list1 == NULL) //若l1先达到NULL，说明l1最后一个节点仍不能大于l2目前节点
        return list2;
    else if(list2 == NULL)
        return list1;//同理
    else if(list1->val <list2->val) //当l1<l2时，l1会到达下一个节点进行比较
    {
        list1->next = mergeTwoLists(list1->next,list2);
        return list1; //在栈弹出时主动权在l1，为了使l2->next连接l1，需返回l1
    }
    else//list2->val <= list1->val
    {
        list2->next = mergeTwoLists(list1,list2->next);
        return list2;//与l1同理
    }
}
```
**递归流程**

```
mergeTwoLists --> mTL | list1 --> l1 | list2 --> l2
l1 = [1,2,5] | l2 = [1,3,4]
=====================================================
l2[1]->next = mTL(1,1->next(3))
    l1[1]->next = mTL(1->next(2),3)
        l1[2]->next = mTL(2->next(5),3)
            l2[3]->next = mTL(5,3->next(4))
                l2[4]->next = mTL(5,4->next(NULL))
-------------------------------------------------
                l1[5]
            l2[4]
        l2[3]
    l1[2]
l1[1]
======================================================             
```
>递归流程可用**画圈法**或则**V型法**来做
##### 两数相加
**题目要求**


给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示意图**
![18381921248691](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage18381921248691.png)

###### 模拟法
```c
struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2)
{
    // 检查输入参数是否为空
    if (l1 == NULL || l2 == NULL)
    {
        return NULL;
    }

    struct ListNode *pa = l1;
    struct ListNode *pb = l2;
    int carry = 0; // 进位

    while (pa != NULL || pb != NULL)
    {
        int x = (pa != NULL) ? pa->val : 0; // 获取当前节点的值，若为空则为0
        int y = (pb != NULL) ? pb->val : 0;
        int sum = x + y + carry; // 计算两个节点和进位的和
        carry = sum / 10;        // 计算进位

        if (pa != NULL)
        {
            pa->val = sum % 10; // 更新节点的值
            if (pa->next == NULL && ((pb != NULL && pb->next != NULL) || carry > 0))
            { // 若pa的下一个节点为空，且pb下一节点不为空或者有进位，则添加一个节点
                pa->next = (struct ListNode *)malloc(sizeof(struct ListNode));
                pa->next->val = 0;
                pa->next->next = NULL;
            }
            pa = pa->next;
        }
        if (pb != NULL)
        {
            pb = pb->next;
        }
    }

    return l1;
}
```
#####  复制带随机指针的链表
**题目要求**

给你一个长度为 **n** 的链表，每个节点包含一个额外增加的**随机指针** `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都**不应指向原链表中的节点** 。

例如，如果原链表中有 X 和 Y 两个节点，其中` X.random --> Y` 。那么在复制链表中对应的两个节点 x 和 y ，同样有` x.random --> y `。

返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index] `表示：

`val`：一个表示 Node.val 的整数。
`random_index`：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 `null` 。
你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

>简单来说，复制一个一摸一样的链表，但地址都不同
>
>**示意图**
><img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage54001116230267.png" alt="54001116230267" style="zoom:50%;" />
>
>###### 哈希表  

<mark>本代码以**CPP**编写</mark>
```cpp
#include <iostream>
#include <unordered_map>

using namespace std;

//链表定义
class Node
{
public:
    int val;
    Node *random;
    Node *next;

    Node(int _val)
    {
        val = _val;
        random = nullptr;
        next = nullptr;
    }
};

class Solution
{
public:
    // 定义哈希表
    unordered_map<Node *, Node *> myMap;

    Node *copyRandomList(Node *head)
    {
        if (head == nullptr)
            return nullptr;
        if (!myMap.count(head))
        {
            Node *newhead = new Node(head->val);            // 创建一个与head一样的新节点;
            myMap[head] = newhead;                          // 将head映射到newhead
            newhead->next = copyRandomList(head->next);     // 使用递归复制新节点
            newhead->random = copyRandomList(head->random); // 调用哈希表复制random指针
        }
        return myMap[head]; // 返回的是一个与head属性相同(地址不同)的newhead指针
    }
};
```

* `myMap[head] = newhead;`，此语句让`head`映射到`newhead`，如**index=2的head节点**映射到**index=2的newhead节点**，当使用`myMap[]`调用时，会返回相应的`newhead`指针。如：传入`head->random`时对应的是**index=2的head节点**，返回了**index=2的newhead节点指针**
* `newhead->next = copyRandomList(head->next);`此语句用于**节点复制**，直到`head==nullptr`前，`newhead`的每一个节点均属于**独立存在状态**。在**栈弹出**时，通过调用`HashMap`，返回与之对应的系节点

###### 关于C++Hash表的拓展

>哈希表（`Hash Table`）是通过散列表（`Hash Table`）实现的。散列表是一种数据结构，它能够以**O(1)时间复杂度**快速<mark>查找、插入和删除</mark>元素

⚪使用`<unordered_map>`头文件，`std`命名空间
⚪定义：`unordered_map <TypeA , TypeB> name;`
* `TypeA`是指**键(Key)**，`TypeB`是指**值(value)**，**键**对应一个**值**，一般来说，**一个键**只能对应**一个值**，但**一个值**可以对应**多个键**
* `name`是哈希表的名字，可以在符合条件范围内任取

⚪使用：`name[key] = value`
>详细信息访问C++[HashTable有关函数](../CPP/CPP笔记.md)


##### 旋转链表
**题目要求**

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点**向右**移动 `k` 个位置。

**示意图**
![274850621230342](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage274850621230342.png)

###### 环模拟
>解题思路：将单链表先构成环，求出真实移动后头节点，断开

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution
{
public:
    ListNode *rotateRight(ListNode *head, int k)
    {
        // 特殊情况：头指针为空或只有一个节点，直接返回头指针
        if (head == nullptr || head->next == nullptr)
        {
            return head;
        }

        int len = 0;
        ListNode *pmove = head;
        
        while (pmove->next != nullptr)
        {
            pmove = pmove->next;
            len++;
        }
        len++; //pmove->next循环判断会少计一长度
        pmove->next = head;// 形成环形链表

        // 计算真实需要移动的位置
        int realLen = len - k % len;

        // 移动到真实位置的前一个节点
        pmove = head;
        for (int i = 0; i < realLen - 1; i++)
        {
            pmove = pmove->next;
        }
        
        ListNode *newHead = pmove->next;// 新的头指针为真实位置的节点
        pmove->next = nullptr;// 断开环形链表

        return newHead;
    }
};

```
## 双链表
### -------------------
<mark>本章节已通过**ChatGPT**验证</mark>
#### 定义链表节点结构体
```c
// 定义链表节点结构体
typedef struct ListNode
{
    int val;
    struct ListNode *prev, *next;
} MyLinkedList;
```
>在定义`*prev`和`*next`时，不可以直接使用`MyLinkedList`

#### 创建链表头
```c
// 创建链表头
MyLinkedList *myLinkedListCreate()
{
    MyLinkedList *head = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (head == NULL)
    {
        printf("Error: Memory allocation failed\n");  //内存不足
        exit(EXIT_FAILURE);
    }
    head->val = 0;
    head->prev = NULL;
    head->next = NULL;
    return head;
}
```
#### 获取链表指定位置的节点值
```c
// 获取链表指定位置的节点值
int myLinkedListGet(MyLinkedList *head, int index)
{
    if (head == NULL || index < 0)
    {
        return -1;
    }

    MyLinkedList *curr = head->next;
    int pos = 0;

    while (curr != NULL)
    {
        if (pos == index)
        {
            return curr->val;
        }
        curr = curr->next;
        pos++;
    }
    return -1;
}
```
>`int类型`函数要返回一个错误时可以使用`return -1`

#### 在链表头添加节点(首位节点)
```c
// 在链表头添加节点
void myLinkedListAddAtHead(MyLinkedList *head, int val)
{
    if (head == NULL)
    {
        printf("Error: Invalid input\n");
        return;
    }

    MyLinkedList *new_node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (new_node == NULL)
    {
        printf("Error: Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }

    new_node->val = val;
    new_node->prev = NULL;
    new_node->next = NULL;

    // 如果链表为空，则新节点成为头结点
    if (head->next == NULL)
    {
        head->next = new_node;
        new_node->prev = head;
    }
    else // 如果链表非空，则插入到头结点后
    {
        new_node->next = head->next;
        new_node->next->prev = new_node;
        head->next = new_node;
        new_node->prev = head;
    }
}
```

#### 在链表尾部添加节点
```c
void myLinkedListAddAtTail(MyLinkedList *head, int val)
{
    if (head == NULL)
    {
        printf("Error: Invalid input\n");
        return;
    }

    MyLinkedList *new_node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (new_node == NULL)
    {
        printf("Error: Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    new_node->val = val;
    new_node->prev = NULL;
    new_node->next = NULL;

    // 如果链表为空，则新节点成为首位结点
    if (head->next == NULL)
    {
        head->next = new_node;
        new_node->prev = head;
    }
    else // 如果链表非空，则插入到链表尾部
    {
        MyLinkedList *curr = head;
        while (curr->next != NULL)
        {
            curr = curr->next;
        }
        curr->next = new_node;
        new_node->prev = curr;
    }
}
```

#### 在链表指定位置插入节点
```c
/* 在链表指定位置插入节点 */
void myLinkedListAddAtIndex(MyLinkedList *head, int index, int val)
{
    // 检查头节点是否存在
    if (head == NULL)
    {
        printf("Error: Head node is not initialized\n");
        return;
    }

    // 检查索引是否合法
    if (index < 0)
    {
        printf("Error: Invalid index\n");
        return;
    }

    // 在链表开头插入节点
    if (index == 0)
    {
        myLinkedListAddAtHead(head, val);
        return;
    }

    // 创建新节点
    MyLinkedList *newNode = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (newNode == NULL)
    {
        printf("Error: Memory allocation failed\n");
        return;
    }
    newNode->val = val;
    newNode->prev = NULL;
    newNode->next = NULL;

    // 遍历链表，找到插入位置的前一个节点
    MyLinkedList *cur = head;
    int pos = 0;
    while (cur->next != NULL)
    {
        if (pos == index - 1)
        {
            break;
        }
        cur = cur->next;
        pos++;
    }

    // 插入节点
    if (cur->next != NULL)
    {
        newNode->next = cur->next;
        newNode->next->prev = newNode;
        cur->next = newNode;
        newNode->prev = cur;
    }
    else // 尾节点
    {
        cur->next = newNode;
        newNode->prev = cur;
    }
}
```
#### 删除链表指定位置的节点
```c
/* 删除链表指定位置的节点 */
void myLinkedListDeleteAtIndex(MyLinkedList *head, int index)
{
    // 检查头节点是否存在
    if (head == NULL)
    {
        printf("Error: Head node is not initialized\n");
        return;
    }

    // 检查索引是否合法
    if (index < 0)
    {
        printf("Error: Invalid index\n");
        return;
    }

    // 遍历链表，找到要删除的节点的前一个节点
    MyLinkedList *cur = head;
    int pos = 0;
    while (cur->next != NULL)
    {
        if (pos == index - 1)
        {
            break;
        }
        cur = cur->next;
        pos++;
    }

    // 删除节点
    if (cur->next != NULL)
    {
        cur->next = cur->next->next;
        if (cur->next != NULL)
        {
            cur->next->prev = cur;
        }
    }
    else // 删除尾节点
    {
        cur->prev->next = NULL;
    }
}
```

解析**删除节点**中的
```c
if (cur->next != NULL)
    {
        cur->next = cur->next->next;
        if (cur->next != NULL)
        {
            cur->next->prev = cur;
        }
    }
```
判断两次**if语句**的原因:
当`cur`位于**倒数第二个节点**时，第一层**if语句**判断为`true`，而经过`cur->next=cur->next->next`后，`cur->next`实际上是指向`null`，因此，无须设置**prev指针**

#### 内存释放-递归
```c
/*内存释放-递归*/
void myListFree(MyLinkedList *node)
{
    if (node->next != NULL)
    {
        myListFree(node->next);
        node->next = NULL;
    }
    node->prev = NULL;
    free(node);
}

void myLinkedListFree(MyLinkedList *head)
{
    MyLinkedList *node = head;
    myListFree(node);
}
```

#### 完整实现
```c
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点结构体
typedef struct ListNode
{
    int val;
    struct ListNode *prev, *next;
} MyLinkedList;

// 创建链表头
MyLinkedList *myLinkedListCreate()
{
    MyLinkedList *head = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (head == NULL)
    {
        printf("Error: Memory allocation failed\n"); // 内存满
        exit(EXIT_FAILURE);
    }
    head->val = 0;
    head->prev = NULL;
    head->next = NULL;
    return head;
}

// 获取链表指定位置的节点值
int myLinkedListGet(MyLinkedList *head, int index)
{
    if (head == NULL || index < 0)
    {
        return -1;
    }

    MyLinkedList *curr = head->next;
    int pos = 0;

    while (curr != NULL)
    {
        if (pos == index)
        {
            return curr->val;
        }
        curr = curr->next;
        pos++;
    }
    return -1;
}

// 在链表头添加节点
void myLinkedListAddAtHead(MyLinkedList *head, int val)
{
    if (head == NULL)
    {
        printf("Error: Invalid input\n");
        return;
    }

    MyLinkedList *new_node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (new_node == NULL)
    {
        printf("Error: Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }

    new_node->val = val;
    new_node->prev = NULL;
    new_node->next = NULL;

    // 如果链表为空，则新节点成为头结点
    if (head->next == NULL)
    {
        head->next = new_node;
        new_node->prev = head;
    }
    else // 如果链表非空，则插入到头结点后
    {
        new_node->next = head->next;
        new_node->next->prev = new_node;
        head->next = new_node;
        new_node->prev = head;
    }
}

// 在链表尾部添加节点
void myLinkedListAddAtTail(MyLinkedList *head, int val)
{
    if (head == NULL)
    {
        printf("Error: Invalid input\n");
        return;
    }

    MyLinkedList *new_node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (new_node == NULL)
    {
        printf("Error: Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    new_node->val = val;
    new_node->prev = NULL;
    new_node->next = NULL;

    // 如果链表为空，则新节点成为首位结点
    if (head->next == NULL)
    {
        head->next = new_node;
        new_node->prev = head;
    }
    else // 如果链表非空，则插入到链表尾部
    {
        MyLinkedList *curr = head;
        while (curr->next != NULL)
        {
            curr = curr->next;
        }
        curr->next = new_node;
        new_node->prev = curr;
    }
}

/* 在链表指定位置插入节点 */
void myLinkedListAddAtIndex(MyLinkedList *head, int index, int val)
{
    // 检查头节点是否存在
    if (head == NULL)
    {
        printf("Error: Head node is not initialized\n");
        return;
    }

    // 检查索引是否合法
    if (index < 0)
    {
        printf("Error: Invalid index\n");
        return;
    }

    // 在链表开头插入节点
    if (index == 0)
    {
        myLinkedListAddAtHead(head, val);
        return;
    }

    // 创建新节点
    MyLinkedList *newNode = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (newNode == NULL)
    {
        printf("Error: Memory allocation failed\n");
        return;
    }
    newNode->val = val;
    newNode->prev = NULL;
    newNode->next = NULL;

    // 遍历链表，找到插入位置的前一个节点
    MyLinkedList *cur = head;
    int pos = 0;
    while (cur->next != NULL)
    {
        if (pos == index - 1)
        {
            break;
        }
        cur = cur->next;
        pos++;
    }

    // 插入节点
    if (cur->next != NULL)
    {
        newNode->next = cur->next;
        newNode->next->prev = newNode;
        cur->next = newNode;
        newNode->prev = cur;
    }
    else // 尾节点
    {
        cur->next = newNode;
        newNode->prev = cur;
    }
}

/* 删除链表指定位置的节点 */
void myLinkedListDeleteAtIndex(MyLinkedList *head, int index)
{
    // 检查头节点是否存在
    if (head == NULL)
    {
        printf("Error: Head node is not initialized\n");
        return;
    }

    // 检查索引是否合法
    if (index < 0)
    {
        printf("Error: Invalid index\n");
        return;
    }

    // 遍历链表，找到要删除的节点的前一个节点
    MyLinkedList *cur = head;
    int pos = 0;
    while (cur->next != NULL)
    {
        if (pos == index - 1)
        {
            break;
        }
        cur = cur->next;
        pos++;
    }

    // 删除节点
    if (cur->next != NULL)
    {
        cur->next = cur->next->next;
        if (cur->next != NULL) 
        {
            cur->next->prev = cur;
        }
    }
    else // 删除尾节点
    {
        cur->prev->next = NULL;
    }
}

/*内存释放-递归*/
void myListFree(MyLinkedList *node)
{
    if (node->next != NULL)
    {
        myListFree(node->next);
        node->next = NULL;
    }
    node->prev = NULL;
    free(node);
}

void myLinkedListFree(MyLinkedList *head)
{
    MyLinkedList *node = head;
    myListFree(node);
}

int main()
{
    MyLinkedList *head = myLinkedListCreate();
    myLinkedListAddAtHead(head, 1);
    myLinkedListAddAtTail(head, 10);
    myLinkedListAddAtIndex(head, 0, 2);
    myLinkedListAddAtIndex(head, 1, 3);
    myLinkedListDeleteAtIndex(head, 1);
    // myLinkedListFree(head);

    MyLinkedList *list_move = head;
    while (list_move != NULL)
    {
        printf("%d\n", list_move->val); // 0 2 1 10
        list_move = list_move->next;
    }

    int val = myLinkedListGet(head, 1); // 1
    printf("val-->%d\n", val);

    system("pause");
}


```
#### 小题
##### 扁平化多级双向链表
**题目要求**

你会得到一个**双链表**，其中包含的节点有一个下一个指针、一个前一个指针和一个**额外的** 子指针 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 多层数据结构 。

给定链表的头节点 `head` ，将链表 扁平化 ，以便所有节点都出现在单层双链表中。让 `curr` 是一个带有子列表的节点。子列表中的节点应该出现在扁平化列表中的 `curr` 之后 和 `curr.next` 之前 。

返回 扁平列表的 `head` 。列表中的节点必须将其 **所有** 子指针设置为 `null` 。

**示意图**
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage404714216230266.png" alt="404714216230266" style="zoom: 80%;" />
![4954316248692](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage4954316248692.png)

###### 深度优先搜索
<mark>此解题方法使用`C++`解决</mark>
```cpp
#include <iostream>
#include <functional>

using namespace std;    

//节点定义
class Node {
public:
    int val;
    Node* prev;
    Node* next;
    Node* child;
};


class Solution
{
public:
    Node *flatten(Node *head)
    {
        if (head == nullptr)
            return nullptr;
        function<Node *(Node *)> flattenList = [&](Node *node)
        {
            Node *cur = node;
            Node *last = nullptr;

            while (cur)
            {
                Node *next = cur->next;
                if (cur->child != nullptr) // 拥有子链表时
                {
                    Node *child_last = flattenList(cur->child); // 传入子链表的头节点,并得到子链表的尾指针

                    // 连接节点
                    cur->child->prev = cur;
                    cur->next = cur->child;

                    if (next != nullptr) // cur后存在节点时
                    {
                        next->prev = child_last;
                        child_last->next = next;
                    }
                    cur->child = nullptr;
                    last = child_last; // 在本次循环结束后，cur会在last后一个节点
                }
                else
                {
                    last = cur; // 记录链表的最后一个节点
                }
                cur = next; // cur前进一节点，当为nullptr时，退出循环并返回前一个节点指针last
            }
            return last;
        };
        flattenList(head); // 运行flattenList的第一步
        return head;
    }
};
```

知识点:
`function<Node *(Node *)> flattenList = [&](Node *node){}；`为使用 **Lambda 表达式**定义的**递归**函数对象
①`function<typeA(typeB)>`是一个**函数指针类型**的定义，它接受一个`typeB`类型的参数，并**返回**一个`typeA`类型的参数。需要使用到`#include <functional>`和`std`
②`flattenList`是一个变量名，用于**调用函数**，可取其他名字
③`[]`是`Lambda表达式`的**捕获列表**，其中`&`表示以**引用方式**捕获<mark>所有外部变量</mark>，也可以用 `=` 表示以**值方式**捕获<mark>所有外部变量</mark>，或者指定具体的外部变量名
④`[](Type name)`是`Lambda表达式`的参数列表，表示这个`Lambda表达`接受一个`Type`类型的参数，`name`是**形参名**
④`{……}；`是函数体，末尾需要`;`

###### 关于C++Lambda表达式的拓展

定义：Lambda表达式是C++11引入的一种便捷的函数对象形式，可以在函数中定义一个匿名函数并直接调用，而无需定义函数名。

`[capture_list] (parameters) -> return_type { body }`

⚪`capture_list`（捕获列表）是一个可选项，用于指定`Lambda函数`在定义时可以访问哪些**外部变量**。捕获列表可以包含以下内容：

Ⅰ.空捕获列表 `[]`：不捕获任何外部变量。
Ⅱ.值捕获`[=]`：以**值**的方式捕获所有外部变量，即**复制**一份外部变量的副本到Lambda函数中。
Ⅲ.引用捕获 `[&]`：以**引用**的方式捕获所有外部变量，即让`Lambda函数`中的变量与外部变量<mark>共享同一地址</mark>。
Ⅳ.显式捕获 `[var1, var2, ...]`：指定要捕获的外部变量的列表。可以选择值捕获或引用捕获，也可以混合使用。
Ⅴ.变量捕获` [=, &var] 或 [&, var]`：混合使用值捕获和引用捕获。在这个例子中，=, &var表示以值的方式捕获**除var以外**的所有外部变量，以<mark>引用的方式捕获var变量</mark>；&var, =则相反，先以引用的方式捕获var变量，再以值的方式捕获其他所有外部变量。

⚪`parameters`（参数列表）：用于指定`Lambda表达式`的**形参列表**，与普通函数的形式相同。

⚪`return type`（返回类型）：用于指定`Lambda表达式`的**返回值类型**，与普通函数的返回类型相同。如果省略，编译器会根据函数体推断返回类型。

⚪`{}`（函数体）：用于指定`Lambda表达式`的函数体，与普通函数的语法相同。

>`[capture list]`、`(parameters)`和`-> return type`是**可选的**，可以根据需要省略。

## 环形链表

### -------------------

```c
环形链表示意图
head---> 1 ---> 2 ---> 3
         ↑             ↓
         ---------------  
```
#### 环形链表的判断

判断环形链表有两种方法
①用哈希表记录
②快慢指针（本章重点）

>快慢指针：设定一个快指针`*fast`和慢指针`slow`，若链表为**环形链表**，则`fast必定会等于slow`（fast绕数圈后追上slow）；若为单链表，则`fast==NULL`或则`fast->next==NULL`


```c
bool listCycle(struct Node *head)
{
    /*判断链表是否为空链表*/
    if (head == NULL || head->next == NULL)
        return false;

    /*新建快、慢指针*/
    struct Node *fast = head;
    struct Node *slow = head;

    /*环形链表判断*/
    while (fast != NULL)
    {
        if (fast->next == NULL)
            return false;

        fast = fast->next->next;
        slow = slow->next;

        if (fast == slow)
            return true;
    }

    return false;
}
```
#### 环形链表入环点查找


>解析





<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage8790919236452.jpeg" alt="8790919236452" style="zoom:67%;" />

设`HEAD`到`入环点`的距离为**a**（不包括`HEAD`和`入环点`），`入环点`到`相遇点`的距离为**b**（包括`相遇点`但不包括`入环点`），`相遇点`到`入环点`的距离为**c**（包括`入环点`但不包括`相遇点`)

>`fast`走过的距离:<mark>**a+n(b+c)+b**</mark>
>`slow`走过的距离:<mark>**a+b**</mark>
因为`fast`速率是`slow`的**两倍**

```
存在以下公式:
    a+n(b+c)+b=2(a+b)
化简:
    a=c+(n-1)(b+c)
```

即`HEAD`到`入环点`的距离等于**n-1圈**加上`相遇点`到`入环点`，因此可以使用**双指针法**

>双指针法：建立一个新的指针`*ptr`指向`HEAD`，`ptr`与`slow`以**同一速率**继续向前，它们<mark>一定会在`入环点`相遇</mark>

```c
struct Node *detectCycle(struct Node *head)
{
    if (head == NULL || head->next == NULL)
        return false;

    /*新建快、慢指针*/
    struct Node *fast = head;
    struct Node *slow = head;

    /*环形链表判断*/
    while (fast != NULL)
    {
        if (fast->next == NULL)
            return NULL;

        fast = fast->next->next;
        slow = slow->next;

        if (fast == slow)
        {
            /*双指针判断*/
            struct Node *ptr = head;
            while (ptr != slow)
            {
                ptr = ptr->next;
                slow = slow->next;
            }
            return ptr;
        }
    }
    return NULL;
}
```


----
## 相交链表
### -----------------------
#### 相交链表的交点查找
概念:两个链表在某一点处**开始指向同一内存位置**
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage532412521230159.png" alt="532412521230159" style="zoom: 67%;" />



注意：
①**首位节点**在同一内存位置也称之为相交
②**相交点**后续节点均处于同一内存位置

>方法一：末端后退法

```c
struct Node *getIntersectionNode(struct Node *headA, struct Node *headB)
{
    if(headA == NULL && headB == NULL)
        return NULL:
        
	struct Node *last_a;
	struct Node *last_b;
	struct Node *list_move;
	struct Node *record = NULL;
	int a = 0, b = 0;

	/*令last_a与last_b指向链表末端且计算长度*/
	list_move = headA;
	while (list_move->next != NULL)
	{
		list_move = list_move->next;
		a++;
	}
	last_a = list_move;

	list_move = headB;
	while (list_move->next != NULL)
	{
		list_move = list_move->next;
		b++;
	}
	last_b = list_move;

	/*从末端向前逐一比较*/
	while (last_a == last_b && (last_a != headA || last_b != headB))
	{
		list_move = headA;
		for (int i = 0; i < a; i++)
			list_move = list_move->next;
		last_a = list_move;
		a--;

		list_move = headB;
		for (int i = 0; i < b; i++)
			list_move = list_move->next;
		last_b = list_move;
		b--;

		if (last_a == last_b)
			record = last_a;
	}

	if (record != NULL)
		return record;
	else if (a == 0 && b == 0 && last_a == last_b) //当A、B链表均只有一个值且相等时
		return headA;
	else
		return NULL;
}
```



若存在结交点则返回结交点指针，若无则返回`NULL`


>方法二：前缀和法

设两链表长度分别为m、n
当`m=n`时，若相交，它们会<mark>同时指向同一内存位置</mark>
当`m!=n`时，因为**m+n=n+m**，因此`listA`遍历A、B链表的长度与`listB`遍历B、A链表的长度相等
```
若有交点，则会在第二次遍历链表时相交
若无交点，则会同时指向NULL
```


```c
struct Node *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if(headA==NULL||headB==NULL)
        return NULL;

	/*双指针*/
    struct Node* listA=headA;
    struct Node* listB=headB; 

	/*和相等*/
    while(listA!=listB){
        listA=(listA==NULL)?headB:listA->next;
        listB=(listB==NULL)?headA:listB->next;
    }
    return listA;
}
```


注意：当判断出它们指向同一内存位置时，**无需再往后面判断**，同一内存位置拥有<mark>单向指向性</mark>

>`headA`与`headB`均为存储正常数值头结点，此题不需要判断`headA->next==NULL || headB->next==NULL`

