# 树

**此笔记由AXuanCreator制作,部分资料来源于网络,GITHUB地址:[AXuanCreator/NOTE-Data-Structure-and-Algorithms: 数据结构与算法的一些笔记，目前基于C++ (github.com)](https://github.com/AXuanCreator/NOTE-Data-Structure-and-Algorithms)**



#### 二叉树的前序遍历
![432331219256822](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage432331219256822.png)
##### 知识点

>前序遍历

* 前序遍历首先访问 **根节点** ，然后遍历 **左子树** ，最后遍历 **右子树** 。
<img src="D:\Files_Work\Vnote\CandCPP\数据结构与算法\vx_images\555223319249491.gif" alt="555223319249491" style="zoom:50%;" />

##### 递归
```cpp
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     TreeNode *left;
     *     TreeNode *right;
     *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
     * };
     */
    class Solution
    {
    public:
        void treeNodePush(TreeNode *ptr, vector<int> &ans)
        {
            if (ptr == nullptr)
                return;

            ans.push_back(ptr->val);       // 将当前节点值插入
            treeNodePush(ptr->left, ans);  // 传递左分支，若存在，则插入值
            treeNodePush(ptr->right, ans); // 传递右分支

            return; // 可不写，仅为理解
        }
        vector<int> preorderTraversal(TreeNode *root)
        {
            vector<int> ans;
            treeNodePush(root, ans);

            return ans;
        }
    };
```
>解析

* 何为前序遍历？前序遍历指将 **根节点** 放在首位，然后遍历左、右子树。也就是说，除了根节点外，左树支点为 **次优先** 级别，那么思路就很清晰了：
    * 优先遍历 **左支点** ， 因为左支点同时也是根节点(除最后一个左支点外)
    * 在遍历完左支点后`(node==nullptr)`，递归开始返回的上一个节点并 **传递右支点** 。 
    * 若对于传递的支点依然存在 **左支点** ，那么会优先遍历左支点，直至左支点为 **空** ， 然后调用下一个函数`treeNodePush(ptr->right, ans)`


##### 迭代
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution
{
public:
    vector<int> preorderTraversal(TreeNode *root)
    {
        vector<int> res;
        
       	// 检测是否为空节点
        if (root == nullptr)
        {
            return res;
        }

        
        stack<TreeNode *> stk;	// 设立栈，先入后出
        TreeNode *node = root;  // 相当于移动节点
        
        while (!stk.empty() || node != nullptr) // 当栈不为空或者node不指向nullptr
        {
            while (node != nullptr) // 先遍历左子树，在遍历的过程中载入节点到栈和容器中
            {
                res.emplace_back(node->val);	// 先将节点值记录到res中
                stk.emplace(node);	// 推入
                node = node->left;	// 向左节点前进
            }
			
            // 此时当前节点node为空节点
            node = stk.top(); 	// 当左子树没有元素，从栈顶(也就是上一个节点)赋值给node
            stk.pop();  	// 栈顶弹出
            node = node->right; 	// 指向右边
        }
        return res;
    }
};

```

>解析

* 迭代和递归其实很相似，递归隐藏了栈入栈出的，而迭代则显式了栈入栈出
* 思路：
    * 进入 **外循环** 的条件是 `!stk.empty() || node != nullptr`，即当`stk`不为空或者`node`指向非空节点
    * 进入外循环后，会再次进入 **内循环**,这个内循环的作用是遍历 **左支点** 并将节点指针 **压入栈**，并且保存值
    * 当左支点已为 **空** ，会从 **栈顶** 拿出一个节点，这个节点是 **空节点** 的上一个节点，并从栈顶 **删除** 这个节点指针(下一次无法再拿出这一节点)。然后将节点指针指向 **当前从栈顶拿出的新节点的右支点**
    * 再次进入 **内循环** ，  记录，反复上面的步骤
    
* 注意：
    * 节点指针一旦从栈里拿出`stk.top()`，就会被同步删除`stk.pop(); `，再也无法回到这个节点。这是一个关键，在循环根节点的右支点时，为了防止再次返回到根节点，此时会直接返回到 **根节点的上一个节点**
    
>`stack<>`的拓展

* `stack<Type> name`表示一个用于存储指向`Type`对象的 **栈** 。栈是一种 **后进先出**（LIFO）的数据结构，只允许在 **栈顶** 插入和删除元素。
* 栈提供以下几种基本操作：
    * `push(x)`：将元素x压入栈顶。
    * `pop()`：从栈顶弹出一个元素。
    * `top()`：获取当前栈顶元素的值。
    * `empty()`：判断栈是否为空。
    * 自己查文档去😝😝

* 栈的相关知识点位于 [队列&栈](队列&栈.md)

##### Morris遍历
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution
{
public:
    vector<int> preorderTraversal(TreeNode *root)
    {
        vector<int> ans;
        TreeNode *cur = root;
        while (cur != nullptr)
        {
            if (cur->left == nullptr)
            {
                // 如果左子树为空，则将当前节点的值加入结果集，并将当前节点更新为其右子节点
                ans.push_back(cur->val);
                cur = cur->right;  // 右子树遍历 / 回到上一个左子树的节点
            }
            else
            {
                // 如果左子树非空，则寻找前驱节点
                TreeNode *predecessor = cur->left;
                while (predecessor->right != nullptr && predecessor->right != cur) // 找到右子节点的尽头
                {
                    predecessor = predecessor->right;
                }
                if (predecessor->right == nullptr)
                {
                    // 如果找到的前驱节点的右子节点为空，将其右子节点指向当前节点，然后将当前节点更新为其左子节点
                    predecessor->right = cur;
                    ans.push_back(cur->val);
                    cur = cur->left;
                }
                else
                {
                    // 如果前驱节点的右子节点为当前节点，说明前驱节点已遍历完，将其右子节点重置为空，然后将当前节点更新为其右子节点
                    predecessor->right = nullptr;
                    cur = cur->right;
                }
            }
        }
        return ans;
    }
};
```

>解析：

* 前驱节点`predecessor`的作用时连接 **相对位置上一个** 的根节点，以让`cur`返回



>图解

<img src="D:\Files_Work\Vnote\CandCPP\数据结构与算法\vx_images\301672311248790.gif" alt="301672311248790" style="zoom:50%;" />

![276211818230365](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage276211818230365.jpg)
#### 二叉树的中序遍历
![485101610248790](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage485101610248790.png)

##### 知识点
>中序遍历

* 遍历顺序：
    * 左子节点
    * 根节点
    * 右子节点
* 解题技巧：无
  
##### 递归
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    void recursionTree(TreeNode* node , vector<int>& ans)
    {
        if(node==nullptr)
            return;

        /*
        * 先抵达相对最底部的左节点
        * 然后记录
        * 探索该节点是否存在右子树
        */
        recursionTree(node->left,ans);
        ans.push_back(node->val);
        recursionTree(node->right,ans);
            
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        recursionTree(root,ans);
        return ans;
    }
};
```
>解析

* 先抵达并记录 **相对位置尾巴** 左子节点
    * 检测此左子支点是否 **存在右子节点**
        * 若存在，则进入 **右子节点** ，不需要先记录，先检测是否为 **根节点** 。若存在，则先遍历至此节点的 **最左子节点**，开始从尾巴到开始记录，然后记录根节点，最后再次检测是都有 **右子节点**
        * 若不存在，则返回上一个节点，记录，然后再次检测此节点是否存在 **右子节点**
* 反复上述步骤

##### 迭代
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:    
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (root == nullptr)
        {
            return ans;
        }
        
        stack<TreeNode*> stk;
        TreeNode* node = root;
        
        while(!stk.empty() || node!=nullptr)
        {
            while(node!=nullptr) //抵达最左子节点
            {
                stk.emplace(node);
                node=node->left;
            }
            node = stk.top();  	// 记录栈顶
            stk.pop();  		// 弹出
            ans.push_back(node->val); // 记录
            node=node->right; //右移动
        }

        return ans;
    }
};
```
>解析

<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage399711111236657.png" alt="399711111236657" style="zoom:50%;" />

* 流程：
```cpp
** F --> B --> A --> nullLeft
** --> top(A) --> pop(A) -- > record(A) -->  nullRight
** -->top(B) --> pop(B) -->record(B) --> D --> C --> nullLeft
** --> top(C) --> pop(C) -->record(C) --> nullRight
** --> top(D) --> pop(D) --> record(D) --> E --> nullLeft
** -->top(E) --> pop(E) --> record(E) -->nullRight
** --> top(F) --> pop(F) --> record(F) --> G --> nullLeft
** -->top(G) --> pop(G) -- record(G) --> I --> nullLeft
** -->top(I) --> pop(I) --> record(I) --> H -->nullLeft
** --> top(H) --> pop(H) --> record(H) --> nullRight
** -->stkEMPTY && nullptr--> out 
```

##### Morris遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        TreeNode *cur = root;
        while (cur != nullptr)
        {
            if (cur->left == nullptr)
            {
                // 如果左子树为空，则将当前节点的值加入结果集，并将当前节点更新为其右子节点
                ans.push_back(cur->val);
                cur = cur->right;  // 右子树遍历 / 回到上一个左子树的节点
            }
            else
            {
                // 如果左子树非空，则寻找前驱节点
                TreeNode *predecessor = cur->left;
                
                // 找到右子节点的尽头
                // pre->right != nullptr 一般触发于右子树末端尚未连接环节，对应下方的if
                // pre->right != cur 一般触发于节点载入环节，对应下方的else
                while (predecessor->right != nullptr && predecessor->right != cur) 
                {
                    predecessor = predecessor->right;
                }
                // 如果找到的前驱节点的右子节点为空，将其右子节点指向当前节点
                // 然后将当前节点更新为其左子节点
                if (predecessor->right == nullptr)
                {
                    predecessor->right = cur;                 
                    cur = cur->left;
                }
                // 如果前驱节点的右子节点为当前节点，说明前驱节点已遍历完
                // 将其右子节点重置为空，然后将当前节点更新为其右子节点
                else
                {  
                    ans.push_back(cur->val);   
                    predecessor->right = nullptr; // 删除连接
                    cur = cur->right;
                }
            }
        }
        return ans;
    }
};
```

>解析

* 起始和前序morris遍历十分相似，唯一不同点在于中序morris遍历是在 **`cur->left == nullptr`** 或 **`predecessor->right == cur`** 时将元素加入到数组尾部
    * 原因：
        * `cur->left == nullptr`,对于这一语句，是因为当节点不再存在 **左子节点** 时，根据中序遍历的 **先左再根后右** 的原则，将左节点加入到数组。然后，会让它前往右子节点，右子节点在为抵达最终点时 **必定存在**且只有唯一一种情况：无论右子节点树有多长，其 **终点** 必定连接`cur`进入右子节点前的 **上一个节点**，达到回溯的效果
           * 注意，右子节点树可能会存在某些节点有 **左支点树**  的情况，此时 `pre` 会再次建立联系
       *  `predecessor->right == cur`，对于这一语句，表明此时`cur`派出的`pre`检测到后面的子节点已经遍历过，不需要重复遍历，此时，会记录节点并`cur=cur->right`
       

![500721818248791](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage500721818248791.jpg)

#### 二叉树的后序遍历
##### 知识点
* 先遍历左子树
* 然后遍历右子树
* 最后访问树的根节点
* 便捷记法：
    * 若当前节点为 **非根节点** 或者 **该根节点下的子节点已遍历完** ， 则记录节点
    
##### 递归
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void recursionTree(TreeNode* node , vector<int>& ans)
    {
        if(node==nullptr)
            return;
        
        recursionTree(node->left,ans);
        recursionTree(node->right,ans);
        ans.push_back(node->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        recursionTree(root,ans);

        return ans;
    }
};
```

>解析

```cpp
recursionTree(node->left,ans);
recursionTree(node->right,ans);
ans.push_back(node->val);
```
* 充分说明了只有当当前节点 **遍历完它的所有子节点后** ，才能被记录。而记录的顺序是：
    * 先左子节点。`recursionTree(node->left,ans);`这语句说明左子节点具有最高优先级
    * 再右子节点
    * 最后根节点
* 若根节点 **无** 左子节点，则先记录 **右** 子节点    

##### 迭代
```cpp
class Solution
{
public:
    vector<int> postorderTraversal(TreeNode *root)
    {
        vector<int> res;
        if (root == nullptr)
        {
            return res;
        }

        stack<TreeNode *> stk;
        TreeNode *prev = nullptr;

        while (root != nullptr || !stk.empty())
        {
            while (root != nullptr) //抵达左子树终点
            {
                stk.emplace(root);
                root = root->left;
            }
            //回到上一节点
            root = stk.top();
            stk.pop();

            //若不存在右子节点，则将节点记录，并将prev指向此节点，root指向空指针等待下次循环被栈顶赋值
            if (root->right == nullptr || root->right == prev)
            {
                res.emplace_back(root->val);
                prev = root;
                root = nullptr;
            }
            //若存在右子节点，则将当前节点加入栈，并往右移动
            else
            {
                stk.emplace(root);
                root = root->right;
            }
        }
        return res;
    }
};

```
>解析

* 在抵达左子树终点后，会返回上一个节点，此时分两种情况
    * ①此节点存在右子树，则 **重新** 入栈，并往右移动
    * ②此节点不存在右子树或者此节点的右子节点 **已被遍历**，此时记录值并移动`prev`和`root`
        * 从何得知已被遍历？
            * `prev`是`root`的上一个节点。当`root->right==nullptr`或者在上一次循环中已经将节点值记录过，都会触发`prev=root`
        * 为何是`root->right==prev`，而不是`root->left==prev`
            * 因为右子树节点在左子树节点访问完毕之后才能被访问，而左子树无论如何都会进入到`if判断`里，即使它的某个节点存在右子树，此时会进入右子树并遍历。简单来说，这样判断可以防止漏掉左子树某个节点的右子树，且左子树拥有最高优先级
* 当触发`root->right==nullptr`或者`root->right==prev`时，都会在下一次循环中跳过**内层While**，直达栈顶赋值

##### Morris遍历
```cpp
class Solution
{
public:
    void addPath(vector<int> &vec, TreeNode *node)
    {
        int count = 0;
        while (node != nullptr) //node为cur->left
        {
            ++count;
            vec.emplace_back(node->val); //从左子节点开始加入元素，直至左子节点的右子树终端
            node = node->right; //遍历左子节点的右子树
        }
        reverse(vec.end() - count, vec.end()); 
        //翻转，因为正确的插入顺序是：右子树尾端->左子节点(根节点)
        //因为是emplace_back尾插法，所以从end()开始计算范围
    }

    vector<int> postorderTraversal(TreeNode *root)
    {
        vector<int> res;
        if (root == nullptr)
        {
            return res;
        }

        TreeNode *cur = root, *predecessor = nullptr;

        while (cur != nullptr)
        {
            predecessor = cur->left; //构建前驱节点，连接cur左子节点的右子树终端-->cur
            if (predecessor != nullptr)
            {
                //当pre的右子节点为空或者该右子树已被连接
                while (predecessor->right != nullptr && predecessor->right != cur)
                {
                    predecessor = predecessor->right;
                }
                //若未曾经连接
                if (predecessor->right == nullptr)
                {
                    predecessor->right = cur; //连接
                    cur = cur->left; //cur继续遍历当前存在的左子树
                    continue;
                }
                else //若曾经连接过
                {
                    predecessor->right = nullptr; //消除连接指针
                    addPath(res, cur->left); //翻转[左子节点-->左子节点的右子树终点]元素
                }
            }
            cur = cur->right; 
            //①当cur抵达左子树的终点时，通过pre创造的通道，回到左子树起点的上一个left连接点
            //②当cur通过pre创造的通道回到上一个节点后，通过这个语句返回上一个节点或者进入右子树
        }
        addPath(res, root); 
        //这里翻转的是Tree的最右子树，在这一条子树中，cur会在末端抵达nullptr退出循环
        //因此最右子树的这段值需要从[根节点开始-->最右子树末端]加入数组然后翻转
        
        return res;
    }
};

```
>~~只可意会，不可言传！~~

* 对于最初根节点的所有左子树而言，是优先被加入到数组的。但它们的加入 **并非** 几个元素一起假如然后翻转，而是一个一个加入。因为对于 **pre未曾遍历过的左子树而言** ，总存在`if (predecessor->right == nullptr)`
* 而对于所有右子树而言，它们都是整棵树加入的，然后翻转
* 对于最右子树而言，在`while`循环里没有被加入，需要在退出循环后重新执行一次`addPath`

~~为什么会有人能写出这么牛逼的算法？？~~

![191241918236658](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage191241918236658.jpg)

#### 二叉树的层序遍历
![352934511230366](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage352934511230366.png)

##### 知识点
>何为层序遍历

*将每一层的元素 **从左到右** 依次加入数组
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage190391614249494.jpg" alt="190391614249494" style="zoom:50%;" />

##### 广度优先搜索[queue][迭代]

```cpp
class Solution
{
public:
    vector<vector<int>> levelOrder(TreeNode *root)
    {
        vector<vector<int>> ret;
        if (!root)
        {
            return ret;
        }

        queue<TreeNode *> q; //queue为队列，先进先出，均从底部进入，顶部出
        q.push(root); //将根节点放入q
        while (!q.empty()) 
        {
            int currentLevelSize = q.size();   //这一层的节点个数
            ret.push_back(vector<int>());  //新增ret容器的最后一行
            for (int i = 1; i <= currentLevelSize; ++i)
            {
                auto node = q.front();  //从前面拿取一个指针
                q.pop();  //将刚拿取的指针从队列里弹出
                ret.back().push_back(node->val);  //在ret的新增的最后一行的尾部添加node->val
                if (node->left) //当node存在左子节点
                    q.push(node->left);  //入队左子节点
                if (node->right) //当node存在右子节点
                    q.push(node->right); //入队右子节点
            }
        }

        return ret;
    }
};
```
>解析

* 这题的核心思想就是，在当前层里，将下一层的节点指针 **从左到右** 依次加入到队列里，利用队列 **先进先出** 的特性，先加入的指针会在下一次while循环优先记录元素
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage443451614246049.gif" alt="443451614246049" style="zoom:50%;" />

###### queue的拓展

 * queue是STL提供的一种容器，用于表示队列结构。它通常被实现为一种适配器，底层使用别的容器，例如deque或list来实现队列的基本操作。
* 队列是一种$FIFO$（先进先出）数据结构。队列支持在队列的 **末尾** 添加元素和在队列的 **前端** 删除元素。被添加到队列中的第一个元素总是第一个被删除。
* 定义：
    * `queue <TypeName> Name;`
* queue常用的基本操作有以下几种：
    * `empty()`：返回queue是否为空。
    * `size()`：返回queue中元素的数量。
    * `front()`：返回queue中的第一个元素。
    * `back()`：返回queue中的最后一个元素。
    * `push()`：在队列的末尾添加一个元素。
    * `pop()`：删除队列中的第一个元素。
        * 其中，front()、back()、push()和pop()对queue的底层容器实现进行了封装，使得它们只能在队列的前后端进行操作。
* queue不能在中间或随意位置添加或删除元素，只能在队列的末尾添加元素，在队列的前端删除元素。这是由于队列的数据结构特性所决定的。
* queue不支持返回 **中间某一个** 元素，仅支持返回头尾元素

##### 深度优先搜索[递归]
```cpp
//层次遍历-深度优先搜索
    vector<vector<int>> levelOrder2(TreeNode *root)
    {
        vector<vector<int>> ret;
        if (!root)
        {
            return ret;
        }

        dfs(root, 0, ret);
        return ret;
    }

    void dfs(TreeNode *root, int level, vector<vector<int>> &ret)
    {
        if (level == ret.size()) //当level等于ret的行数时，新增一行
        {
            ret.push_back(vector<int>());
        }

        ret[level].push_back(root->val); //将当前节点的值放入ret的level行的尾部
        if (root->left) //当root拥有左支点时
        {
            dfs(root->left, level + 1, ret); //递归下一层
        }
        if (root->right) //先左后右
        {
            dfs(root->right, level + 1, ret);
        }
    }
```
>解析

* 深度优先搜索实质上是将二叉树摆成阶梯型
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage582210014248792.jpg" alt="582210014248792" style="zoom:50%;" />
* 它的遍历规则是：
    * 优先列遍历，在遍历的过程中记录节点 `if (root->left)`
    * 抵达列遍历的 **尾部**（如3）后，开始检测时否有 **右支点** `if (root->right)`，若有，则以这个右支点为 **起始** ， 开始新一轮列遍历
* 注意：
    * `dfs`一般指$DFS(Deep FirstSearch)$，也称为深度优先搜索
    * ` if (level == ret.size())`时，新增一行至尾部，防止下一次递归`level+1`时溢出

##### 对BFS(广度优先搜索)和DFS(深度优先搜索)的图解
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage438731514256825.gif" alt="438731514256825" style="zoom:50%;" />

#### 二叉树的最大深度

![559060715241803](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage559060715241803.png)

##### 深度优先搜索DFS[递归]
```cpp
// 二叉树的最大深度-深度优先搜索   
    int maxDepthDfs(TreeNode *root)
    {
        if (root == nullptr)
            return 0;
        int maxLen = 1, len = 1;
        dfs(maxLen, len, root);
        return maxLen;
    }
    void dfs(int &maxLen, int len, TreeNode *node)
    {
        if (node->left) // 若node有左支点，则递归下一层，并将len+1
            dfs(maxLen, len + 1, node->left);
        maxLen = max(maxLen, len);

        if (node->right) // 同理，先左后右
            dfs(maxLen, len + 1, node->right);
        maxLen = max(maxLen, len);
    }
```

##### 广度优先搜索BFS[queue]
```cpp
// 二叉树的最大深度-广度优先搜索
    int maxDepthBfs(TreeNode *root)
    {
        if (root == nullptr)
            return 0;

        queue<TreeNode *> q;
        q.push(root);
        int maxLen = 0;
        while (!q.empty())
        {
            ++maxLen; // 每次循环，层数+1
            int len = q.size();

            for (int i = 1; i <= len; ++i)
            {
                auto node = q.front();
                q.pop();
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
        }
        return maxLen;
    }
```
>解析

* 和层次遍历的BFS差不多，在每一次 **进入`while`循环** 都代表这这一层是存在的，所以 `++maxLen`
    * 唯一的不同点是少了新增行语句`ret.push_back(vector<int>());`

#### 对称二叉树
![464480212230367](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage464480212230367.png)

##### 广度优先搜索BFS[迭代][queue]
```cpp
//对称二叉树
    bool isSymmetric(TreeNode *root)
    {
        return bfsSymmetric(root, root);
    }
    bool bfsSymmetric(TreeNode *lf, TreeNode *rf)
    {
        queue<TreeNode *> q;
        q.push(lf);
        q.push(rf);
        bool sw = 1;
        while (sw && !q.empty())
        {
            lf = q.front();
            q.pop();
            rf = q.front();
            q.pop();

            if (!lf && !rf)                           // 当lf为空以及rf为空时
                continue;                             // 跳过以下q的存储
            if ((!lf || !rf) || (lf->val != rf->val)) // 只要lf为空或者rf为空或者val值不相等，则不对称
                return false;

            //以对称式结构推入
            q.push(lf->left); // 可能会推入nullptr
            q.push(rf->right);

            q.push(lf->right);
            q.push(rf->left);
        }

        return true;
    }
```

>解析

使用广度优先搜索的形式对每一层的对称节点进行比较

##### 深度优先搜索DFS[递归]
```cpp
// 对称二叉树
    bool check(TreeNode *p, TreeNode *q)
    {
        if (!p && !q) //若在第一个check()中判断正确，则表示两个节点均为左、右支点，可以进行下一个check的判断
            return true;
        if (!p || !q)
            return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }
    bool isSymmetric(TreeNode *root)
    {
        return check(root, root);
    }

```
>解析

* 此题的递归函数分为三种情况
    * 传递的两个节点均为`nullptr`
        * 若此时是`check(p->left, q->right)`，则进行下一个`check(p->right, q->left)`
        * 若此时是最后一个`check()`，则表示均已抵达终点且堆成，此时返回`true`
    * 传递的两个节点有一个**不为`nullptr`**，此时返回`false`，且不会再次进行递归
        * 注意，虽然 `(!p || !q)`中也存在p、q均为`nullptr`的情况，但是这种情况在前面的if判断里已经被返回true
    * 传递的两个节点均 **不为`nullptr`** 
        * 此时先比较它们的值
        * 若值相等，则比较它们的对称位置

#### 路径总和
![245293514230367](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage245293514230367.png)
##### 深度优先搜索DFS[递归]
###### 做法一
```cpp
// 路径总和
    bool check(TreeNode *node, int sum, int target)
    {
        bool sw = false;
        if (sum == target && (node->left == nullptr && node->right == nullptr))
            sw = true;

        if (node->left && !sw) //当存在node->left且无符合target的情况下
            sw = check(node->left, sum + node->left->val, target);
        if (node->right && !sw)  //同理
            sw = check(node->right, sum + node->right->val, target);

        return sw;
    }
    bool hasPathSum(TreeNode *root, int targetSum)
    {
        if (root == nullptr)
            return false;
        int sum = root->val;
        return check(root, sum, targetSum);
    }
```
> 解析

* 若存在某路径符合条件，则`sw=true`，此时会跳过下面的两个`if移动`语句，一直`return true`

###### 做法二  
```cpp
    bool hasPathSum(TreeNode *root, int sum)
    {
        if (root == nullptr)
        {
            return false;
        }
        if (root->left == nullptr && root->right == nullptr)
        {
            return sum == root->val;
        }
        return hasPathSum(root->left, sum - root->val) ||
               hasPathSum(root->right, sum - root->val);
    }
```
>解析

* 此方法使用了$surplus$剩余值，通过选出 **叶子节点** 来判断是否和`surplus(sum)`相等，若相等，则会一直返回`true`，而`||`的特性：当一方为`true`时，会 **跳过** 之后的判定，直接返回`true`

##### 广度优先搜索BFS[queue]
```cpp
//路径总和-广度优先搜索
    bool hasPathSumBfs(TreeNode *root , int target)
    {
        if(root==nullptr)
            return false;
        queue<TreeNode*> qNode; 
        queue<int> qSum;

        qNode.push(root);
        qSum.push(root->val);
        while(!qNode.empty())
        {
            int len = qNode.size();

            for(int i=1;i<=len;++i)
            {
                auto node = qNode.front(); //获取并弹出节点指针
                qNode.pop();
                auto sum = qSum.front();  //获取并弹出节点总值
                qSum.pop();

                if(node->left==nullptr && node->right==nullptr && sum==target)
                    return true;
                if(node->left) //当存在左子节点时，存储总值和左子节点指针
                {
                    qSum.push(sum+node->left->val);
                    qNode.push(node->left);
                }
                if(node->right)  //同理
                {
                    qSum.push(sum+node->right->val);
                    qNode.push(node->right);
                }
            }
        }

        return false;        
    }
```
>解析

* 此算法并不能做到 **实时判断相等** ， 为了配合`qNode`，存储总值也只能使用`queue`已达到同步的效果。而`queue`的特性时 **先进后出** ，因此并不能第一时间等到答案，往往需要在下一个 `while循环` 里才能判断
* 广度优先搜索得到的路径总和为 **最短路径**

#### 从中序与后序遍历序列构造二叉树
![226535020230368](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage226535020230368.png)
##### 递归
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution
{
    unordered_map<int, int> myMap;
    int pIndex;

public:
    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder)
    {
        pIndex = postorder.size() - 1;
        int index = 0;
        for (auto &val : inorder) // 记录哈希值，前序值-->下标，方便通过前序值锁定范围
            myMap[val] = index++;
        return helper(0, pIndex, inorder, postorder);
    }

    TreeNode *helper(int left, int right, vector<int> &inorder, vector<int> &postorder)
    {
        if(left>right)
            return nullptr;
        int val = postorder[pIndex--];
        TreeNode *root = new TreeNode(val); // 建立节点并附上值

        int index = myMap[val]; // 寻找下标，确定范围

        // 由于是使用后序遍历数组从后往前确定根节点的，所有需要从右边开始递归
        root->right = helper(index + 1, right, inorder, postorder);
        root->left = helper(left, index - 1, inorder, postorder);

        return root;
    }
};
```

>解析

<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage591185020248794.png" alt="591185020248794" style="zoom: 33%;" />

* 这题的思路是根据后序遍历列表的特性确定根节点
    * 后序列表的遍历顺序是 `左节点-->右节点-->根节点`，也就是说，最后一个一定是 **最初的根节点**
    * 后续列表的 **从右往左** 对应的节点特性顺序是 `根节点-->右节点-->左节点` ， 与正序遍历相反，它的 **右具有最高优先度**
        * 举个例子

```python
//     1
//    / \
//   2   3
//  / \   \
// 4   5   6
//    / \
//   7   8
//  / \
// 9  10

// 二叉树的后序遍历为：4 9 10 7 8 5 2 6 3 1
// 二叉树的前序遍历为：1 2 4 5 7 9 10 8 3 6
// 二叉树的中序遍历为：4 2 9 7 10 5 8 1 3 6

```

* 根据特性，我们可以使用后序列表和中序列表匹配的值确定范围
    * 对于`中序[1,3,5,7,9] | 后序[x,x,x,x,5]` 我们可以确定`根`的值是5。因此根据中序遍历顺序`左-->中-->右`可以分出范围`左子树[1,3] | 右子树[7,9]`，根据不断地递归缩小范围。当范围不存在了`left>right`,就代表这个节点 **无左子节点或右子节点** ， 此时`return nullptr`
    
* 为何是先`root->right`
    * 这与**后序列表**的遍历方式有关。我们设定了一个下标值`pIndex`，它一开始指向尾部，然后逐渐向前。因此，`val`的值优先在右子树，而后才在左子树。还是反过来的原理:    `根节点-->右节点-->左节点`
      
##### 迭代
```cpp
TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder)
{
    if (postorder.size() == 0)
    {
        return nullptr;
    }
    auto root = new TreeNode(postorder[postorder.size() - 1]);
    auto s = stack<TreeNode *>();
    s.push(root);
    int inorderIndex = inorder.size() - 1;
    for (int i = int(postorder.size()) - 2; i >= 0; i--)
    {
        int postorderVal = postorder[i]; //posterorderVal总是为node->val前一个节点
        auto node = s.top();
        if (node->val != inorder[inorderIndex])
        {
            node->right = new TreeNode(postorderVal);
            s.push(node->right);
        }
        else
        {
            while (!s.empty() && s.top()->val == inorder[inorderIndex])
            {
                node = s.top();//node为s.top()的父节点
                s.pop();
                inorderIndex--;
            }
            node->left = new TreeNode(postorderVal); //
            s.push(node->left);
        }
    }
    return root;
}
```
>解析

中序遍历=`[15 ,  9 , 10 , 3 , 20 , 5 , 7 ,  8 , 4]`
后序遍历=`[15 , 10 ,  9 , 5 ,  4 , 8 , 7 , 20 , 3]`
```python
        3
       / \
      9  20
     / \   \
    15 10   7
           / \
          5   8
               \
                4


```


* 中序遍历的顺序 : 左 -> 根 -> 右 。 反过来 : `右->根->左`
* 后序遍历的顺序 : 左 -> 右 -> 根 。 反过来 : `根->右->左`
    * 即它们在反过来遍历的情况下`左节点`的优先级最低
* `postorderVal`总是比`node->val`领先一个节点值，即`node`充当着 **父节点的作用**
* 在`else`判断中，`node`总是领先`s.top()`，因为当`while`条件符合后，便退出循环
* `stack s`所存储的都是 **当前节点的祖先节点**
* 需结合递归的想法：当后序遍历的某个节点值与前序节点值相等时，在这个节点的范围里，左边是左支点，右边是右支点。注意，需要理清范围的概念：
    * 范围是 **不断缩小的**，如在`中序=[1,3,5,7,9]`中，后序的最后一位是`5`，则`[1,3]`均为5的 **左子树节点**，`[7,9]`均为 **右子树节点**。若倒数第二位是`9`，则`[7]`为9的 **左子树节点** ， `nullptr`为 `右子树节点`。这个范围是根据**父节点**不断缩小的，每当确立了一个父节点，则可以理解为一把刀，将这个列表切成两份
    * 因此，我们可以从中获得特性：当存在`node->val != inorder[inorderIndex]`时，因为中序列表该节点的位置 **无右节点值** 或者 **右节点值已被遍历过（被刀切开了）** ， 此时可以认为， **此节点为某个父节点的 左子节点**
* 左子节点的求法： 当触发`else`时，我们需要确定插入该左节点的 **父节点** 。由反向前序遍历 `右->根->左`和反向后序遍历`根->右->左`可得知：
    * 栈中(某一个范围的正向反序遍历)每一个节点的左儿子都还没有被遍历过，这些节点的顺序和 **它们在反向中序遍历中出现的顺序一定是相反的** 。因此只需和栈中的`val`对比，当不相等了，则表示`node`为该做子左子节点的父节点(`node`领先`s.top`，但做比较的是`s.top()->val`)
        * 把`->左`忽略，这两个遍历就是相反顺序

* 我想上面的话我过段时间都看不懂，所以用一种也许好理解点的方法去解释：
    * 当节点A不匹配时，它会找它的 **父节点**。它的父节点在 **中序遍历** 列表中，右边表示右子树节点，左边表示左子树节点。
    * 因此，节点A需要回溯并**跳过**所有同在右子树的兄弟姐妹，而栈正好记录了它们。
    * 当节点A回溯到一个在中序遍历列表中与其 **不相等**  的节点时，这个节点在中序遍历列表中是一个根节点，右边是该节点的所有右子树节点。
    * 实际上，这个节点是节点A的 **父节点的父节点** ，因为我们总是需要用下一个节点判断前一个节点是否为节点A的父节点。
    * 因此，会多走一步。在这种情况下，我们将新节点创建为左子节点，并将其推入栈中。

#### 从中序与前序遍历序列构造二叉树
![279152919230370](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage279152919230370.png)
##### 递归
```cpp
    unordered_map<int,int> myMap();
    int preIndex;
    TreeNode* helper (int left,int right , vector<int>& preorder, vector<int>& inorder)
    {
        if(left>right) //范围不存在了
            return nullptr;

        int inorderVal = preorder[preIndex++];
        TreeNode* root = new TreeNode(inorderVal);
        int index = myMap[inorderVal];

        root->left = helper(left,index-1,preorder,inorder);
        root->right = helper(index+1,right,preorder,inorder);

        return root;
    }
    TreeNode *buildTreeA(vector<int> &preorder, vector<int> &inorder)
    {
        preIndex = 0;

        int index=0;
        for(auto& val : inorder) //将中序列表节点值载入哈希表
            myMap[val] = index++;

        return helper(0,inorder.size()-1,preorder,inorder);
    }
```

>解析

* 和中后序递归原理差不多，前序遍历顺序为: `根->左->右`，即我们可以将前序遍历从前面开始逐个找出与中序列表对应的位置节点，该节点左边为左子树，右边为右子树
* 与中后序递归不相同的是，本递归使用了 **先left再right**，因为前序遍历是 `左->右`，因此需要对应。而后序反向遍历是 `根->右->左`,因此后序是先右后左

##### 迭代
```cpp
//迭代
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder)
    {
        if (preorder.size() == 0)
        {
            return nullptr;
        }
        auto root = new TreeNode(preorder[0]);
        auto s = stack<TreeNode *>();
        s.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < inorder.size(); i++)
        {
            int preorderVal = preorder[i]; // posterorderVal总是为node->val前一个节点
            auto node = s.top();
            if (node->val != inorder[inorderIndex])
            {
                node->left = new TreeNode(preorderVal);
                s.push(node->left);
            }
            else
            {
                while (!s.empty() && s.top()->val == inorder[inorderIndex])
                {
                    node = s.top(); // node为s.top()的父节点
                    s.pop();
                    inorderIndex++;
                }
                node->right = new TreeNode(preorderVal); //
                s.push(node->right);
            }
        }
        return root;
    }
```

>解析

* 和中后序的迭代反着来就是了，~~我也不太懂~~
* 给你看看官方解释吧！
* 上方有自己的解释，~~虽然狗屁不通~~
![](vx_images/114844219248796.png =500x)

#### 填充每个节点的下一个右侧节点指针
![345432819230371](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage345432819230371.png)

##### 广度优先搜索[BFS]
```cpp
//DFS
    Node *connect(Node *root)
    {
        if(root == nullptr)
            return nullptr;

        queue<Node*> q;
        q.push(root);

        while(!q.empty())
        {
            int len = q.size();
            auto preNode = q.front(); //preNode在node节点的左边
            for(int i=1;i<=len;++i)
            {
                auto node = q.front();
                q.pop();
                if(node!=preNode)
                {
                    node->next = preNode;
                    preNode = node;
                }                   
                else
                    preNode->next = nullptr;
                
                if(node->right)  //先右遍历再左遍历
                    q.push(node->right);
                if(node->left)
                    q.push(node->left);
               
            }
        }
        return root;
    }
```
>解析

* 根据queue来建立next指针

##### 原地建立
```cpp
    Node *connect(Node *root)
    {
        if (root == nullptr)
        {
            return root;
        }

        // 从根节点开始
        Node *leftmost = root;

        while (leftmost->left != nullptr)
        {

            // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针
            Node *head = leftmost;

            while (head != nullptr)
            {

                // CONNECTION 1
                head->left->next = head->right;

                // CONNECTION 2
                if (head->next != nullptr)
                {
                    head->right->next = head->next->left; //连接不同父节点的两个相邻节点
                }

                // 指针向后移动
                head = head->next;
            }

            // 去下一层的最左的节点
            leftmost = leftmost->left;
        }

        return root;
    }
```
>解析

* 当同一个 **父节点** 的左右节点，我们可以通过 `head->left->next = head->right`
* 当 **父节点** 不相同的相邻节点，因为在 **上一层** 已经建立了这两个父节点的 `next关系` ， 因此我们可以使用 `head->right->next = head->next->left`来连接这两个节点
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage544875019236664.png" alt="544875019236664" style="zoom:50%;" />
#### 填充每个节点的下一个右侧节点指针Ⅱ
![386433619248797](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage386433619248797.png)

##### 广度优先搜索[BFS]
```cpp
//BFS
    Node *connect(Node *root)
    {
        if(root == nullptr)
            return nullptr;

        queue<Node*> q;
        q.push(root);

        while(!q.empty())
        {
            int len = q.size();
            auto preNode = q.front(); //preNode在node节点的左边
            for(int i=1;i<=len;++i)
            {
                auto node = q.front();
                q.pop();
                if(node!=preNode)
                {
                    node->next = preNode;
                    preNode = node;
                }                   
                else
                    preNode->next = nullptr;
                
                if(node->right)  //先右遍历再左遍历
                    q.push(node->right);
                if(node->left)
                    q.push(node->left);
               
            }
        }
        return root;
    }
```
>解析

* 和Ⅰ完全相同，思路相同，广度万岁！

#### 二叉树的最近公共祖先
![276210716230372](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage276210716230372.png)

##### 深度优先搜索
```cpp
class Solution
{
public:
    TreeNode* ans;
    bool *dfs(TreeNode* node , TreeNode* p , TreeNode* q)
    {
        if(node==nullptr)
            return false;

        bool lson = dfs(node->left,p,q);
        bool rson = dfs(node->right,p,q);

        if((lson&&rson) || ((node==p||node==q)&&(lson||rson)))
            ans = root;

        return lson || rson || (node==p || node==q);
        
    }
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        dfs(root,p,q);
        return ans;
    }
};
```

>解析

* `if((lson&&rson) || ((node==p||node==q)&&(lson||rson)))`
    * 当前节点的左右节点 **同时** 符合条件或者任意**左右子树的**节点 和 **当前节点** 符合条件
* `return lson || rson || (node==p || node==q);`
    * 若左节点或者右节点或者当前节点符合条件，则返回 `true`
* 当找到符合条件的节点时，它的 **子树** 都会变成 `true`

##### 哈希表
```cpp
class Solution
{
public:
    unordered_map<int, TreeNode *> fa;
    unordered_map<int, bool> vis;
    void dfs(TreeNode *root) // 存储哈希表，fa表示父节点[val-->node],vis表示
    {
        if (root->left != nullptr)
        {
            fa[root->left->val] = root;
            dfs(root->left);
        }
        if (root->right != nullptr)
        {
            fa[root->right->val] = root;
            dfs(root->right);
        }
    }
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        fa[root->val] = nullptr; // 根节点在hash里表示nullptr
        dfs(root);

        while (p != nullptr)
        {
            vis[p->val] = true; // 感染子树
            p = fa[p->val];     // 回到父节点，直到p为root
        }
        while (q != nullptr)
        {
            if (vis[q->val]) // 当前节点位于p的感染路径
                return q;
            q = fa[q->val]; // 回到父节点，直到q为root
        }
        return nullptr;
    }
};

```
>解析

* 思路和递归大致相同，都是通过 **感染路径** 来进行判断
    1. 先将 **除root外** 的所有节点加入`hash`，用它们的值对应 **父节点**
    2. 使用p进行感染路径。p会通过调用 `fa-hash`来不断抵达它的父节点，并令它们都为 `true`(root也会变为true)
    3. 使用q检查感染路径。若q发现当前的节点是 **p感染过** 的，代表着此时的q是原本的p、q的祖先节点 
    
#### 二叉树的序列化与反序列化
![497685119248798](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage497685119248798.png)

##### 广度优先遍历
```cpp
class Codec
{
public:
    // 将数组转化为字符串格式
    // 广度优先遍历

    //tree to string
    string serialize(TreeNode *root)
    {
        if (!root)
        {
            return "";
        }

        string data = "";
        queue<TreeNode *> q;
        q.push(root);

        while (!q.empty())
        {
            int len = q.size();

            for (int i = 1; i <= len; ++i)
            {
                auto node = q.front();
                q.pop();
                if (!node) //若节点为空，则转序为null
                {
                    data += "null,";
                    continue;
                }
                data += to_string(node->val) + ",";
                q.push(node->left);
                q.push(node->right);
            }
        }

        return data;
    }

    //string to tree
    TreeNode *deserialize(string data)
    {
        if (data.empty())
            return nullptr;

        list<string> dataArray;
        string str;

        //将字符串转化为数组list
        for (auto &ch : data)
        {
            if (ch == ',')
            {
                dataArray.push_back(str);
                str.clear();
            }
            else
            {
                str.push_back(ch);
            }
        }
        if (!str.empty()) // 存储最后的字符串
        {
            dataArray.push_back(str);
            str.clear();
        }

        //将数组转化为二叉树，广度优先遍历
        TreeNode *root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin()); // 删除
        queue<TreeNode *> q;
        q.push(root);

        while (!q.empty() && !dataArray.empty())
        {
            int len = q.size();

            for (int i = 1; i <= len; ++i)
            {
                auto node = q.front();
                q.pop();

                if (dataArray.front() != "null")
                {
                    node->left = new TreeNode(stoi(dataArray.front()));
                    q.push(node->left);
                }
                else
                {
                    node->left = nullptr;
                }
                dataArray.erase(dataArray.begin());

                if (dataArray.front() != "null")
                {
                    node->right = new TreeNode(stoi(dataArray.front()));
                    q.push(node->right);
                }
                else
                {
                    node->right = nullptr;
                }
                if (!dataArray.empty()) // 防止数组越界
                    dataArray.erase(dataArray.begin());
            }
        }

        return root;
    }
};

```
>解析

* 使用广度优先遍历进行转序
    * 若当前节点 **不为空** ， 则`data += to_string(node->val) + ",";`
    * 若当前节点 **空** ， 则`data += "null,";`，并跳过后序的节点推入
*  使用广度优先遍历进行反转序
    * 先将`data`中逗号与逗号之间的元素存入`list`
        * 注意，习惯性问题：若`data`尾巴没有逗号，则需要进入`if (!str.empty())`进行额外赋值，虽然这题尾巴存在逗号
    * 当`list`的首个元素不为`null`时，创建节点并 **依次** 赋值给`node->left 、node->right`，同时，删除`list`的首个元素；
    * 若`list`元素为`nullptr`，则指向`nullptr`

##### 深度优先遍历
```cpp
class Codec
{
public:
    // tree to data
    string serialize(TreeNode *root) //main
    {
        string ret;
        rserialize(root, ret);
        return ret;
    }
    void rserialize(TreeNode *root, string &str)
    {
        if (root == nullptr)
        {
            str += "None,";
        }
        else
        {
            str += to_string(root->val) + ",";
            rserialize(root->left, str);
            rserialize(root->right, str);
        }
    }

    // data to tree
    TreeNode *deserialize(string data)  //main
    {
        //将字符串转换为list
        list<string> dataArray;
        string str;
        for (auto &ch : data)
        {
            if (ch == ',')
            {
                dataArray.push_back(str);
                str.clear();
            }
            else
            {
                str.push_back(ch);
            }
        }
        if (!str.empty())
        {
            dataArray.push_back(str);
            str.clear();
        }
        //将list转换为树
        return rdeserialize(dataArray);
    }
    TreeNode *rdeserialize(list<string> &dataArray)
    {
        if (dataArray.front() == "None")
        {
            dataArray.erase(dataArray.begin());
            return nullptr;
        }

        TreeNode *root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin());
        root->left = rdeserialize(dataArray);
        root->right = rdeserialize(dataArray);
        return root;
    }
};

```
>解析

* 使用递归的方式转序，再使用递归的方式反转序，原理和广度遍历转序一样