# 杂七杂八的算法

### 深度优先搜索[DFS]

#### 理论

深度优先搜索实际上是一种深度探索，以 `二叉树`举例，深度优先搜索会优先遍历完一颗子树，然后再遍历子树的子树

<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimageimage-20230412185528520.png" alt="image-20230412185528520" style="zoom:50%;" />

在这颗二叉树中，会优先遍历子树`1-2-4-8`，然后遍历`5`,然后遍历`1-3-6`,最后遍历`7`。

即在二叉树的深度优先搜索中，**左子树** 拥有最大权限



#### 深度优先搜索的实现

深度优先搜索一般使用 `递归`，可以创建一个函数或者使用`lambda`



#### 小题

##### 1.传递信息

![image-20230412190032787](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimageimage-20230412190032787.png)

> 题目：传递信息，A传给B，B传给C……问有多少种方案传递给E
>
> 注意：传递具有`单向性`，除非题目给出`[A,B],[B,A]`，此时我们认为`A、B具有双向性`

代码实现:

```cpp
/*DFS深度优先搜索*/
int numWays(int n, vector<vector<int>> &relation, int k)
{
    vector<vector<int>> edges(n);
    for (auto &edge : relation)
    {
        int src = edge[0], dst = edge[1];
        edges[src].push_back(dst); //二维数组，代表一个映射关系，src能对应多个dst
    }

    int ways = 0;

    //lambda
    function<void(int, int)> dfs = [&](int index, int steps) 
    {
        if(steps>k) return;  //当传送的步数大于目标步数，则无需再进行传输
        if (steps == k) //当次数=目标次数，进行index的判断
        {
            if (index == n - 1)//共有n位玩家，传送的终点的n-1，index代表玩家编号
            {
                ++ways; //可行路径+1
            }
            return;
        }

        //传送index的可传送路径，如0-->[1,2],表示0-->1 / 0-->2，先传输1
        //在下一次dfs中index=1且步数+1
        //若edges[index]无任何节点,则for循环执行
        for (int to : edges[index]) 
        {
            dfs(to, steps + 1);
        }
        
        return;
    };
    dfs(0, 0);
    return ways;
}
```

> 解析

对于`edge`为`0-->[1,2] , 1-->[3,5,4] , 2-->[6]`而言，此时`n=7,steps=2`

以 `树状图` 形式：

<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimageimage-20230412190210341.png" alt="image-20230412190210341" style="zoom:50%;" />

流程：

```cpp
    0-->1
        1-->3 
            return
        1-->5
            return
        1-->4
            return
    0-->2
        2-->6
            true
```

##### 2.岛屿数量

<img src="assets/image-20230412200525199.png" alt="image-20230412200525199"  />

> 题目: 算有多少个岛屿，岛屿的判定条件为 `1周围均为0`



代码实现

```cpp
class Solution
{
    //建立移动数组
    constexpr static int dx[4] = {0, 1, 0, -1};
    constexpr static int dy[4] = {1, 0, -1, 0};

public:
    void dfs(int row, int col , vector<vector<char>>& grid)
    {
        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != '1')
            return;

        grid[row][col] = '0'; //当grid符合条件时，将其变为0
        
        //移动
        for (int i = 0; i < 4; ++i)
        {
            dfs(row+dx[i],col+dy[i],grid);
        }
    };
    int numIslands(vector<vector<char>> &grid)
    {   
        int island = 0;

        for (int i = 0; i < grid.size(); ++i)
        {
            for (int j = 0; j < grid[0].size(); ++j)
            {
                if (grid[i][j] == '1')
                {
                    dfs(i, j,grid);
                    island++; 
                }
            }
        }
        return island;
    }
};
```

> 解析

这题的`dfs`用于 **污染岛屿** ， 即将`1`变为`0`。每一次污染结束后，`island++`并继续寻找是否有 **未被污染** 的岛屿

* 从原理上来讲，使用`visited数组`来替代用`0`污染岛屿亦可，但在此题的 *特殊测试例子* 下会发生超时现象



### 广度优先搜索BFS

#### 理论

广度优先搜索着重于 `层的遍历` ，以二叉树为例子，它会从顶层开始，当一层的节点全部遍历完了，就进入到下一层

<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimageimage-20230412203617445.png" alt="image-20230412203617445" style="zoom:50%;" />

在广度优先搜索中，遍历顺序是`1 --> 2-3 --> 4-5-6-7 --> 8`

#### 广度优先搜索的实现

* 多数使用`队列queue`

* 实现模板：

```cpp
void BFS()
{
	//建立队列
	queue<Type> name;
	queue.push(val);
	
	while(!name.empty())
	{
		int len = name.size();
		for(int i=1;i<=len;++i)
		{
			//提取队列首元素并弹出
			auto node = q.front();
			q.pop();
			
			//队列入队的判断
			if()
			......
		}
	}
}
```



#### 小题

##### 岛屿数量

![image-20230412205521732](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimageimage-20230412205521732.png)

> 题目: 算有多少个岛屿，岛屿的判定条件为 `1周围均为0`

代码实现:

```cpp
class Solution
{
    constexpr static int dx[4] = {0, 1, 0, -1};
    constexpr static int dy[4] = {1, 0, -1, 0};

public:
    int numIslands(vector<vector<char>> &grid)
    {
        int island = 0;
        queue<pair<int, int>> q;

        for (int i = 0; i < grid.size(); ++i)
            for (int j = 0; j < grid[0].size(); ++j)
                if (grid[i][j] == '1')
                {
                    island++;
                    
                    //BFS模板
                    q.push({i, j});
                    while (!q.empty())
                    {
                        int len = q.size();
                        for (int k = 1; k <= len; ++k)
                        {
                            auto [v1, v2] = q.front();
                            q.pop();
                            if (grid[v1][v2] == '1')
                            {
                                grid[v1][v2] = '0';
                                for (int t = 0; t < 4; ++t)
                                    if (v1 + dx[t] >= 0 && v1 + dx[t] < grid.size() && v2 + dy[t] >= 0 && v2 + dy[t] < grid[0].size() && grid[v1 + dx[t]][v2 + dy[t]] == '1')
                                        q.push({v1 + dx[t], v2 + dy[t]});
                            }
                        }
                    }
                }
        return island;
    }
};
```

















